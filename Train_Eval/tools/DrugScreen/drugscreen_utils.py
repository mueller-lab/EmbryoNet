import argparse
import json
import matplotlib.lines as lines
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import numpy as np
import os
import pandas as pd
from string import ascii_uppercase


class DrugScreenExcelReader:
    """
    A class with utilities for plotting drug screen predictions.
    """
    path_params = "./drugscreen_parameters.json"

    def __init__(self, num_screen, path_src):
        self.num_screen = int(num_screen)
        self.path_src = path_src

        self.parameters = self.fn_json_load(self.path_params)

    def file_excel_load(self):
        """Load excel file."""
        return pd.read_excel(self.path_src, names=self.parameters['cols_detections'])

    @staticmethod
    def fn_json_load(path_json):
        """Load JSON file."""
        with open(path_json, 'rb') as file_json:
            content = json.load(file_json)
        return content


class DrugScreenPhenotypeAnalyzer(DrugScreenExcelReader):
    """
    A class for plotting drug screen predictions.

    Usage:
    DrugScreenPhenotypeAnalyzer(
    number of model,
    number of plate,
    number of screening library [2840, 2854],
    path to Excel file with predictions,
    path to save plots to
    )()

    """
    def __init__(self, num_model, num_plate, num_screen, path_src, path_dst):
        super().__init__(num_screen, path_src)
        self.num_model = num_model
        self.num_plate = int(num_plate)

        self.dir_save = f'{path_dst}/model_{num_model}back/'
        self.name_output = f'{num_screen}_plate{str(num_plate).zfill(3)}_model{num_model}'
        self.path_output = f'{self.dir_save}{self.name_output}'

        self.fileformat = '.svg'
        self.dpi = 500
        self.fontsize = 8
        self.fontsize_labels_plate = 18
        self.fontsize_legend = 12
        self.fontsize_suptitle = 18
        self.fontsize_screeninfo = 15
        self.handleheight = 2 / 1.5
        self.handlelength = 3 / 1.5
        self.legendloc = 'lower center'
        self.legendloc2 = self.legendloc
        self.legend_ncols = 1
        self.limit_line = 10
        _, self.labels = self.fn_fig_legend_handles()
        self.plot_top = float(0.86)
        self.plot_bottom = float(0.08)
        self.plot_left = float(0.08)
        self.plot_right = float(0.92)
        self.plot_hspace = float(0.392)
        self.plot_wspace = float(0.01)
        self.pos_suptitle = (0.5, 1.0)
        self.pos_screeninfo = (0.5, 0.95)
        self.offset_labels_plate = 0.04
        self.col_marks_pos_y = self.plot_top + 0.05

        self.box_x_left = - 0.04
        self.box_x_middle = 0.012
        self.box_x_right = 0.03
        self.box_y_top = 0.08
        self.box_y_middle = - 0.01
        self.box_y_bottom = 0.01
        self.box_color = "#3B3B3B"
        self.box_linewidth = 4
        self.screen_title = f'SCREEN-WELLÂ® ICCB Known Bioactives library'
        self.screen_info = f'Library: BML-{num_screen}\t ' \
                           f'Plate: {str(num_plate).zfill(3)}\t ' \
                           f'Model: model_{num_model}back\t '

    def __call__(self, **kwargs):
        """Plot figures displaying phenotype predictions generated by model."""
        file_excel = self.file_excel_load()
        print(f'[LOADING] BML-{self.num_screen} plate {self.num_plate} model_{self.num_model} Overview', end='\r')
        self.plot_charts(file_excel, mode="bar_chart", save_fig=True)
        print(f'[LOADING] BML-{self.num_screen} plate {self.num_plate} model_{self.num_model} Plate exact', end='\r')
        self.plot_plate_exact(file_excel, save_fig=True, **kwargs)
        print(f'[LOADING] BML-{self.num_screen} plate {self.num_plate} model_{self.num_model} Majority vote', end='\r')
        self.plot_plate_majority_vote(file_excel, save_fig=True, **kwargs)

    def fn_drugname(self, name_original):
        """Format name of drug for plotting."""
        if isinstance(name_original, float):
            drugname = 'Control'
        else:
            if 2 * self.limit_line > len(name_original) > self.limit_line:
                if len(name_original[self.limit_line:]) <= 2:
                    drugname = name_original
                else:
                    drugname = name_original[:self.limit_line] + '-\n' + name_original[self.limit_line:]
            elif len(name_original) > self.limit_line * 2:
                if len(name_original[self.limit_line * 2:]) <= 2:
                    drugname = name_original[:self.limit_line] + '-\n' + \
                               name_original[self.limit_line:]
                else:
                    drugname = name_original[:self.limit_line] + '-\n' + \
                               name_original[self.limit_line:self.limit_line * 2] + '-\n' +\
                               name_original[self.limit_line * 2:]
            else:
                drugname = name_original
        return drugname

    def fn_fig_legend_handles(self):
        patch_unknown = mpatches.Patch(color=self.parameters['colors']['UNKNOWN'], label='UNKNOWN')
        patch_normal = mpatches.Patch(color=self.parameters['colors']['NORMAL'], label='NORMAL', ec=(0, 0, 0))
        patch_nodal = mpatches.Patch(color=self.parameters['colors']['NODAL'], label='NODAL')
        patch_boom = mpatches.Patch(color=self.parameters['colors']['BOOM'], label='BOOM')
        patch_bmp = mpatches.Patch(color=self.parameters['colors']['BMP'], label='BMP')
        patch_wnt = mpatches.Patch(color=self.parameters['colors']['WNT'], label='WNT')
        patch_pcp = mpatches.Patch(color=self.parameters['colors']['PCP'], label='PCP')
        patch_shh = mpatches.Patch(color=self.parameters['colors']['SHH'], label='SHH')
        patch_ra = mpatches.Patch(color=self.parameters['colors']['RA'], label='RA')
        patch_fgf = mpatches.Patch(color=self.parameters['colors']['FGF'], label='FGF')

        handles = [patch_unknown, patch_nodal, patch_bmp, patch_fgf, patch_normal, patch_wnt,
                   patch_ra, patch_boom, patch_pcp, patch_shh]
        labels = [h._label for h in handles]

        return handles, labels

    @staticmethod
    def my_autopct(pct):
        return ('%1.2f%%' % pct) if pct != 0 else ''

    def plot_charts(self, df, **kwargs):
        """Plot pie chart and table based on counts of phenotypes.

        Parameters
        ----------
        df: pandas dataframe
            Dataframe containing numbers of embryos for different phenotypes.
        **kwargs

        Returns
        -------
        None.
        """
        counts, total_number_embryos = self.phenotypes_count_plate(df)
        counts_sorted, labels_sorted, colors_sorted, counts_percent, explode_sorted = self.values_sort(counts)
        counts_sorted = counts_sorted.to_numpy()
        mode = kwargs.get("mode", "bar_chart")

        fig, ax = plt.subplots(figsize=(10, 10))

        if mode == "bar_chart":
            _ = self.plot_bar_chart(ax, counts_sorted, colors_sorted, labels_sorted)
        elif mode == "pie_chart":
            _ = self.plot_pie_chart(fig,
                                    counts_sorted,
                                    colors_sorted,
                                    explode_sorted,
                                    labels_sorted,
                                    (1, 1, 1),
                                    **kwargs)

        else:
            raise KeyError(f'[{self.__class__.__name__}][plot_charts] Wrong mode key.')

        if kwargs.get("plot_legend", True):
            handles, _ = self.fn_fig_legend_handles()
            plt.legend(handles, labels_sorted, loc='best', fontsize=8)

        if kwargs.get('title', None) is None:
            plt.suptitle(str(self.screen_title),
                         fontsize=self.fontsize_suptitle)
            fig.text(self.pos_screeninfo[0], self.pos_screeninfo[1] - 0.05,
                     str(self.screen_info + 'Plot: Overview').expandtabs(),
                     fontsize=self.fontsize_screeninfo,
                     horizontalalignment='center')
        else:
            plt.title(title, fontsize=15, y=1.08)
        if mode == 'pie_chart':
            plt.axis("off")
        if kwargs.get('save_fig', False):
            if kwargs.get('path_save', None) is None:
                path_save = f'{str(self.path_output)}_overview{self.fileformat}'
            else:
                path_save = kwargs['path_save']
            plt.savefig(path_save, dpi=300)
        else:
            plt.tight_layout()
            plt.show()

    @staticmethod
    def plot_bar_chart(ax, counts, colors, labels):
        """Plot a bar chart based on count values."""
        num_bars = np.arange(len(counts))
        ax.bar(num_bars, counts, color=colors, ec=(0, 0, 0), tick_label=labels,
               width=0.5)
        heights = 0
        for p in ax.patches:
            heights += p.get_height()
        for p in ax.patches:
            width = p.get_width()
            height = p.get_height()
            perc = height/heights * 100
            x, y = p.get_xy()
            ax.annotate(f'{perc:.2f}%', (x + width/2, y + height + heights * 0.01), ha='center')
        return ax

    def plot_box_add(self, fig):
        """Add a box similar to shape of multiwell plate around well plots."""
        # Bottom line
        ln1 = lines.Line2D([self.plot_left + self.box_x_left, self.plot_right + self.box_x_right],
                           [self.plot_bottom - self.box_y_bottom, self.plot_bottom - self.box_y_bottom],
                           c=self.box_color,
                           lw=self.box_linewidth)
        # Left line
        ln2 = lines.Line2D([self.plot_left + self.box_x_left, self.plot_left + self.box_x_left],
                           [self.plot_top + self.box_y_middle, self.plot_bottom - self.box_y_bottom],
                           c=self.box_color,
                           lw=self.box_linewidth)
        # Right line
        ln3 = lines.Line2D([self.plot_right + self.box_x_right, self.plot_right + self.box_x_right],
                           [self.plot_top + self.box_y_top, self.plot_bottom - self.box_y_bottom],
                           c=self.box_color,
                           lw=self.box_linewidth)
        # Diagonal line
        ln4 = lines.Line2D([self.plot_left + self.box_x_left, self.plot_left + self.box_x_middle],
                           [self.plot_top + self.box_y_middle, self.plot_top + self.box_y_top],
                           c=self.box_color,
                           lw=self.box_linewidth)
        # Top line
        ln5 = lines.Line2D([self.plot_left + self.box_x_middle, self.plot_right + self.box_x_right],
                           [self.plot_top + self.box_y_top, self.plot_top + self.box_y_top],
                           c=self.box_color,
                           lw=self.box_linewidth)
        for ln in (ln1, ln2, ln3, ln4, ln5):
            ln.set_solid_capstyle('round')
            fig.add_artist(ln)
        return fig

    def plot_pie_chart(self, fig, counts, colors, explode, labels, position, **kwargs):
        """Plot a pie chart based on count values."""
        ax = fig.add_subplot(position[0], position[1], position[2])
        ax.pie(counts,
               autopct=self.my_autopct,
               colors=colors,
               explode=explode,
               labels=[''] * len(labels),
               labeldistance=1,
               pctdistance=1.1,
               textprops={'fontsize': int(kwargs.get("fontsize", 10))},
               wedgeprops={"edgecolor": (0, 0, 0)})

        if kwargs.get("donut_plot", False):
            centre_circle = plt.Circle((0, 0), 0.5, fc='white')
            fig = plt.gcf()
            fig.gca().add_artist(centre_circle)
        ax.axis('equal')
        return ax

    def plot_plate_exact(self, df, filename=None, title=None, save_fig=False, **kwargs):
        """
        Plot overview of pie charts for drug screen plate.

        Parameters
        ----------
        df: pandas dataframe
            Dataframe containing numbers of embryos for different phenotypes.
        filename: str
            Optional filepath to save figure to. If no filename is specified, default filename will be created.
        title: str
            Optional title to be displayed with figure.
        save_fig: bool
            Indicate whether fig should be saved to file or not. Default is set to False.

        Returns
        -------
        None.
        """
        fig = plt.figure(figsize=(15, 10))

        if os.path.isfile(kwargs.get('lookup_table', False)):
            lookup_table = pd.read_excel(kwargs['lookup_table'])
            lookup_table = lookup_table.set_index('index_well')

        for index, row in df.iterrows():
            position = (8, 12, index + 1)
            counts, total_number_embryos = self.phenotypes_count_well(row)
            counts_sorted, labels_sorted, colors_sorted, counts_percent, explode_sorted = self.values_sort(counts)

            ax = fig.add_subplot(position[0], position[1], position[2])
            ax.pie(counts_sorted,
                   autopct=None,
                   colors=colors_sorted,
                   explode=explode_sorted,
                   labels=[''] * len(labels_sorted),
                   labeldistance=None,
                   wedgeprops={"edgecolor": (0, 0, 0)})
            if os.path.isfile(kwargs.get('lookup_table', False)):
                drugname = self.fn_drugname(lookup_table.loc[row['index_well']].values[0])
            else:
                drugname = self.fn_drugname(row['index_well'])
            ax.set_title(drugname, fontsize=self.fontsize, pad=0.05)

        plt.subplots_adjust(left=float(self.plot_left),
                            bottom=float(self.plot_bottom),
                            right=float(self.plot_right),
                            top=float(self.plot_top),
                            wspace=float(self.plot_wspace),
                            hspace=float(self.plot_hspace))

        fig = self.plot_box_add(fig)

        handles, labels = self.fn_fig_legend_handles()
        fig.legend(handles, labels, handleheight=self.handleheight, handlelength=self.handlelength,
                   loc=self.legendloc, fontsize=self.fontsize_legend, ncol=round(len(self.labels) / self.legend_ncols))

        ax_list = fig.axes
        xs = []
        ys = []
        for ax in ax_list:
            xs.append(round(ax.get_position().x0, 5))
            ys.append(round(ax.get_position().y0, 5))

        i = 1
        xs = sorted(list(set(xs)))
        for x in xs:
            fig.text(x + 0.015,
                     self.col_marks_pos_y, str(i).zfill(2),
                     fontsize=self.fontsize_labels_plate)
            i += 1
        i = 0
        ys = reversed(sorted(list(set(ys))))
        for y in ys:
            fig.text(xs[0] - self.offset_labels_plate,
                     y + 0.025,
                     ascii_uppercase[i],
                     fontsize=self.fontsize_labels_plate)
            i += 1
        if title is None:
            plt.suptitle(str(self.screen_title),
                         fontsize=self.fontsize_suptitle,
                         x=self.pos_suptitle[0],
                         y=self.pos_suptitle[1])
            fig.text(self.pos_screeninfo[0], self.pos_screeninfo[1],
                     str(self.screen_info + 'Plot: Exact').expandtabs(),
                     fontsize=self.fontsize_screeninfo,
                     horizontalalignment='center')
        else:
            plt.suptitle(title, fontsize=self.fontsize_suptitle, x=self.pos_suptitle[0], y=self.pos_suptitle[1])
        if save_fig:
            if filename is None:
                filename = f'{str(self.path_output)}_plate_exact{self.fileformat}'
            else:
                pass
            plt.savefig(filename, dpi=self.dpi)
        else:
            plt.show()

    def plot_plate_majority_vote(self, df, filename=None, title=None, save_fig=False, **kwargs):
        """Plot overview of pie charts for drug screen plate based on majority vote results.

        Parameters
        ----------
        df: pandas dataframe
            Dataframe containing numbers of embryos for different phenotypes.
        filename: str
            Optional filepath to save figure to. If no filename is specified, default filename will be created.
        title: str
            Optional title to be displayed with figure.
        save_fig: bool
            Indicate whether fig should be saved to file or not. Default is set to False.

        Returns
        -------
        None.
        """
        fig = plt.figure(figsize=(15, 10))

        if os.path.isfile(kwargs.get('lookup_table', False)):
            lookup_table = pd.read_excel(kwargs['lookup_table'])
            lookup_table = lookup_table.set_index('index_well')

        for index, row in df.iterrows():
            position = (8, 12, index + 1)
            count, label, color = self.votes_count_well(row, 0)
            ax = fig.add_subplot(position[0], position[1], position[2])
            ax.pie(count,
                   autopct=None,
                   colors=color,
                   labels=[''],
                   labeldistance=None,
                   wedgeprops={"edgecolor": (0, 0, 0)})
            if os.path.isfile(kwargs.get('lookup_table', False)):
                drugname = self.fn_drugname(lookup_table.loc[row['index_well']].values[0])
            else:
                drugname = self.fn_drugname(row['index_well'])
            ax.set_title(drugname, fontsize=self.fontsize, pad=0.05)

        plt.subplots_adjust(left=float(self.plot_left),
                            bottom=float(self.plot_bottom),
                            right=float(self.plot_right),
                            top=float(self.plot_top),
                            wspace=float(self.plot_wspace),
                            hspace=float(self.plot_hspace))

        fig = self.plot_box_add(fig)

        handles, labels = self.fn_fig_legend_handles()
        fig.legend(handles, labels, handleheight=self.handleheight, handlelength=self.handlelength,
                   loc=self.legendloc2, fontsize=self.fontsize_legend, ncol=round(len(self.labels)/self.legend_ncols))

        ax_list = fig.axes
        xs = []
        ys = []
        for ax in ax_list:
            xs.append(round(ax.get_position().x0, 5))
            ys.append(round(ax.get_position().y0, 5))

        i = 1
        xs = sorted(list(set(xs)))
        for x in xs:
            fig.text(x + 0.015, self.col_marks_pos_y, str(i).zfill(2), fontsize=self.fontsize_labels_plate)
            i += 1
        i = 0
        ys = reversed(sorted(list(set(ys))))
        for y in ys:
            fig.text(xs[0] - self.offset_labels_plate,
                     y + 0.025, ascii_uppercase[i],
                     fontsize=self.fontsize_labels_plate)
            i += 1
        if title is None:
            plt.suptitle(str(self.screen_title),
                         fontsize=self.fontsize_suptitle,
                         x=self.pos_suptitle[0],
                         y=self.pos_suptitle[1])
            fig.text(self.pos_screeninfo[0], self.pos_screeninfo[1],
                     str(self.screen_info + 'Plot: Majority vote').expandtabs(),
                     fontsize=self.fontsize_screeninfo,
                     horizontalalignment='center')
        else:
            plt.suptitle(title, fontsize=self.fontsize_suptitle, y=1)

        if save_fig:
            if filename is None:
                filename = f'{str(self.path_output)}_plate_majority{self.fileformat}'
            else:
                pass
            plt.savefig(filename, dpi=self.dpi)
        else:
            plt.show()

    def phenotypes_count_plate(self, df):
        """Assess phenotype frequency from drug screen analysis.

        Parameters
        ----------
        df: pandas dataframe
            Dataframe containing numbers of embryos for different phenotypes.

        Returns
        -------
        counts: pandas series
            Series object containing counts of different phenotypes.
        total_number_embryos: numpy.int64
            Number of all embryos represented in dataframe.
        """
        counts = df[self.labels].sum()
        total_number_embryos = counts.sum()

        return counts, total_number_embryos

    def phenotypes_count_well(self, series):
        """
        Assess phenotype frequency from single well instance of drug screen analysis.

        Parameters
        ----------
        series: pandas series
            Series object containing information of well.

        Returns
        -------
        counts: pandas series
            Series object containing counts of different phenotypes.
        total_number_embryos: numpy.int64
            Number of all embryos represented in dataframe.
        """
        counts = series[self.labels]
        total_number_embryos = counts.sum()

        return counts, total_number_embryos

    def values_sort(self, counts):
        """
        Sort the counts, labels and colors by number of embryos in each class.

        Parameters
        ----------
        counts: pandas series
            Series object containing counts of different phenotypes.

        Returns
        -------
        counts_sorted: pandas series
            Series object containing counts of different phenotypes.
        labels_sorted: list
            List of phenotype classes sorted by number of embryos in each class.
        colors_sorted: list
            List of colors corresponding to phenotype classes sorted by number of embryos in each class.
        """
        counts = counts[counts != 0]
        counts_sorted = counts.sort_values()
        labels_sorted = counts_sorted.keys()
        colors_sorted = [self.parameters['colors'][label] for label in labels_sorted]
        counts_percent = counts_sorted / counts_sorted.sum()

        explode_sorted = [0] * len(counts_sorted)
        for i in range(len(counts_sorted)):
            if counts_percent[i] < 25:
                explode_sorted[i] = 0

        return counts_sorted, labels_sorted, colors_sorted, counts_percent, explode_sorted

    def votes_count_well(self, series, mode):
        """Assess phenotype frequency from single well instance of drug screen analysis.

        Parameters
        ----------
        series: pandas series
            Series object containing information of well.
        mode: int
            Specifies which vote type should be returned.
            Type 0 for MajorityVote, Type 1 for Bordered, Type 2 for Centered.

        Returns
        -------
        vote: str
            Classname of vote of phenotype prediction.
        color: tuple
            Color to be displayed in diagram to represent well.
        """
        votes = series[['MajorityVote', 'Bordered', 'Centered']]
        if mode == 0:
            vote = votes['MajorityVote']
        elif mode == 1:
            vote = votes['Bordered']
        elif mode == 2:
            vote = votes['Centered']
        else:
            vote = votes['Centered']

        if vote.startswith('--Undecided'):
            # print(vote.split('--'))
            vote = 'UNDECIDED'
            color = (0.53, 0.53, 0.53)
        else:
            color = self.parameters['colors'][vote]

        count = [100]
        color = [color]
        label = [vote]
        return count, label, color


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input_path',
                        help='Path to excel file with predictions for drug screen plate.',
                        required=True)
    parser.add_argument('-l', '--lookup_table_path',
                        help="Path to excel file containing different names for wells."
                             "Original well names must have column name 'index_well',"
                             "column with new well names must have column name 'name_well'.",
                        default=False)
    parser.add_argument('-m', '--model',
                        help='Model version used for prediction.',
                        required=True)
    parser.add_argument('-o', '--output_path',
                        help='Path to save plots document to.',
                        required=True)
    parser.add_argument('-p', '--plate_number',
                        help='Number of drug screen plate.',
                        required=True)
    parser.add_argument('-s', '--screen_number',
                        help='Indicates which screen is being analyzed. Either 2840 or 2843.',
                        required=True)
    args = parser.parse_args()
    phenotypeanalyzer = DrugScreenPhenotypeAnalyzer(args.model,
                                                    args.plate_number,
                                                    args.screen_number,
                                                    args.input_path,
                                                    args.output_path)
    phenotypeanalyzer(lookup_table=args.lookup_table_path)
