import argparse
import pathlib
from collections import Counter
import glob
import json
import os
import pandas as pd
from scipy.spatial import distance
import string


class DrugScreenJsonReader:
    """
    A class for summarizing predictions generated by EmbryoNet.

    Usage:
    DrugScreenJsonReader(
    number of plate,
    number of screening library [2840, 2854],
    path to directory where subdirectories with predictions for wells are located,
    path to save Excel file with predictions to,
    directory name where JSON files containing predictions can be found within well subdirectories
    )()

    """
    path_params = "./drugscreen_parameters.json"

    def __init__(self, num_plate, num_screen, path_src, path_dst, sign_dir):
        self.num_plate = int(num_plate)
        self.num_screen = int(num_screen)
        self.path_dst = path_dst
        self.path_src = path_src
        self.sign_dir = sign_dir

        self.parameters = self.fn_json_load(self.path_params)

        self.center_distance_limit = 750
        self.center_image = (1024, 1024)
        self.detections_classes = ['UNKNOWN', 'NORMAL', 'NODAL', 'BOOM', 'BMP',
                                   'WNT', 'PCP', 'SHH', 'RA', 'FGF', 'CUT']
        self.detections_counts = {_k: 0 for _k in self.detections_classes}
        self.ljust = 50

    def __call__(self):
        """
        Extract predictions from EmbryoNet-generated JSON files and
        combine predictions with treatment information in one
        Excel file.
        """
        paths_jsons = self.paths_jsons_get()
        df_dst = self.detections_df_get(paths_jsons)
        self.detections_df_save(df_dst)

    @staticmethod
    def fn_json_load(path_json):
        """Load JSON file."""
        with open(path_json, 'rb') as file_json:
            content = json.load(file_json)
        return content

    def count_types(self, detection_list):
        """
        Create a dictionary of detected embryos with class,
        detection center and detection distance to image center.
        """
        detections = {}
        for detection in detection_list:
            detection_id = detection['id']
            detection_class = detection['className']
            x1, y1 = detection['brx'], detection['bry']
            x2, y2 = detection['tlx'], detection['tly']

            center_x = int(x1 + (x2 - x1) / 2)
            center_y = int(y1 + (y2 - y1) / 2)

            detection_center = (center_x, center_y)
            detection_distance = distance.euclidean(detection_center,
                                                    self.center_image)

            detections[detection_id] = [detection_class,
                                        detection_center,
                                        detection_distance]
        return detections

    @staticmethod
    def counter_most_common_check(counter_object):
        """
        Assess which phenotype is predicted most often for a selected
        drug treatment.
        """
        counter_max = 0
        name_undecided = '--Undecided'
        most_common = None

        for count in counter_object:
            if int(count[1]) > counter_max:
                counter_max = int(count[1])
                name_undecided = name_undecided + '--' + count[0]
                most_common = count[0]
            elif int(count[1]) == counter_max:
                counter_max = int(count[1])
                name_undecided = name_undecided + '--' + count[0]
                most_common = name_undecided + '--' + count[0]
            else:
                break

        return most_common

    def detections_df_get(self, paths_jsons):
        """
        Count detections from JSON files for complete plate
        and store as dataframe with treatment information.
        """
        df_detections = pd.DataFrame(columns=self.parameters['cols_detections'])
        for well_index in paths_jsons:
            detections_timestamps = {}
            files_jsons = paths_jsons[well_index]

            for i in range(len(files_jsons)):
                path_json = paths_jsons[well_index][i]
                labels = self.fn_json_load(path_json)
                detections = self.count_types(labels['detection_list'])
                detections_timestamps[i] = detections
                
            print(f'[INFO] Working on well: {well_index}'.ljust(self.ljust))
            
            detections_filtered = self.detections_filter(detections_timestamps)
            
            counts, detection_all, detection_border, \
                detection_center = self.detections_evaluate(detections_filtered)

            df_detections.loc[well_index] = [well_index,
                                             counts['UNKNOWN'],
                                             counts['NORMAL'],
                                             counts['NODAL'],
                                             counts['BOOM'],
                                             counts['BMP'],
                                             counts['WNT'],
                                             counts['PCP'],
                                             counts['SHH'],
                                             counts['RA'],
                                             counts['FGF'],
                                             counts['CUT'],
                                             detection_all,
                                             detection_border,
                                             detection_center]
        df_detections = df_detections.set_index('index_well')
        return df_detections

    def detections_evaluate(self, detections):
        """
        Count phenotype predictions of embryos for a selected
        drug treatment.
        """
        counts = self.detections_counts.copy()
        counts_border = self.detections_counts.copy()
        counts_center = self.detections_counts.copy()
        
        for detection in detections:
            counts[detections[detection][0]] += 1

            if detections[detection][2] > self.center_distance_limit:
                counts_border[detections[detection][0]] += 1
            else:
                counts_center[detections[detection][0]] += 1

        counter_all = Counter(counts)
        counter_border = Counter(counts_border)
        counter_center = Counter(counts_center)

        most_common_all = counter_all.most_common()
        most_common_border = counter_border.most_common()
        most_common_center = counter_center.most_common()

        detection_all = self.counter_most_common_check(most_common_all)
        detection_border = self.counter_most_common_check(most_common_border)
        detection_center = self.counter_most_common_check(most_common_center)

        return counts, detection_all, detection_border, detection_center

    @staticmethod
    def detections_filter(detections_timestamps):
        """
        Filter out detections where embryos were tracked inconsistently.
        """
        embryos = pd.DataFrame(columns=['counts'])
        num_timepoints = len(list(detections_timestamps.keys()))
        print("num_timepoints: ", num_timepoints)

        for timestamp in list(detections_timestamps.keys()):
            for embryo_id in detections_timestamps[timestamp]:
                if embryo_id not in embryos.index:
                    embryos.loc[embryo_id, 'counts'] = 0
                embryos.loc[embryo_id, 'counts'] += 1

        embryos_filtered = embryos[embryos['counts'] > int(num_timepoints * 0.0)]

        embryos_filtered = list(embryos_filtered.index)

        embryos_compare = []
        detections_filtered = {}
        #print("detections_timestamps: ", detections_timestamps)
        countImages = 0
        for timestamp in reversed(detections_timestamps.keys()):
            for embryo_id in detections_timestamps[timestamp]:               
                #if embryo_id in embryos_filtered:
                #    if embryo_id in embryos_compare:
                #        pass
                #    else:
                #        embryos_compare.append(embryo_id)
                #        detections_filtered[embryo_id] = detections_timestamps[timestamp][embryo_id]
                if detections_timestamps[timestamp][embryo_id][0] != 'UNKNOWN':
                    #print(detections_timestamps[timestamp][embryo_id][0])
                    detections_filtered[countImages] = detections_timestamps[timestamp][embryo_id]
                    countImages += 1
            #if sorted(set(embryos_compare)) == sorted(embryos_filtered):
            #    break
        #print("detections filtered !!!!!!!!!!!!!!!!!!!!!!!!!!")        
        #print("detections_filtered : ", detections_filtered)        
        return detections_filtered

    def detections_df_save(self, df_output):
        """Save dataframe to Excel file."""
        if self.path_dst.endswith('.xlsx'):
            pass
        else:
            self.path_dst = f'{self.path_dst}/{self.num_screen}' \
                            f'evaluation_drug_screen_plate' \
                            f'{str(self.num_plate)}.xlsx'
            self.path_dst = self.path_dst.replace('\\', '/')

        df_output.to_excel(self.path_dst)

    def paths_jsons_get(self):
        """
        Load filepaths of JSON files containing
        EmbryoNet generated predictions.

        Parameters
        ----------
        self

        Returns
        -------
        paths_jsons: dict
            Dictionary with keys of well directory names
            and values of lists of sorted image paths.
        """
        paths_jsons = dict()

        paths_wells = [
            p_dir for p_dir in
            sorted(glob.glob(f"{self.path_src}/*/"))
            if os.path.isdir(p_dir)
        ]
        for path_well in paths_wells:
            well_position = str(pathlib.PurePath(path_well).stem)
            pattern_glob = f'{path_well}/{self.sign_dir}/*.json'
            paths_jsons[well_position] = sorted(glob.glob(pattern_glob))

        return paths_jsons


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input_path',
                        help='Path to directory with subdirectories for wells containing'
                             'machine learning model generated predictions.',
                        required=True)
    parser.add_argument('-d', '--directory_signature',
                        help='Directory name where JSON files can be found within well subdirectories.',
                        required=True)
    parser.add_argument('-o', '--output_path',
                        help='Path to save new excel document to.',
                        required=True)
    parser.add_argument('-p', '--plate_number',
                        help='Number of drug screen plate.',
                        required=True)
    parser.add_argument('-s', '--screen_number',
                        help='Indicates which library is being analyzed. Either 2840 or 2843.',
                        required=True)
    args = parser.parse_args()

    jsonreader = DrugScreenJsonReader(args.plate_number,
                                      args.screen_number,
                                      args.input_path,
                                      args.output_path,
                                      args.directory_signature)

    jsonreader()
